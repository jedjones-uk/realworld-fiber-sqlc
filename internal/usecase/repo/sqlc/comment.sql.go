// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: comment.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one

WITH inserted_comment AS (
    INSERT INTO comments (article_id, user_id, body, created_at, updated_at)
        VALUES (
                   (SELECT id FROM articles WHERE slug = $1),
                   $2,
                   $3,
                   CURRENT_TIMESTAMP,
                   CURRENT_TIMESTAMP
               )
        RETURNING id, created_at, updated_at, body, user_id
)
SELECT
    ic.id,
    ic.created_at,
    ic.updated_at,
    ic.body,
    u.username,
    u.bio,
    u.image,
    EXISTS (
        SELECT 1
        FROM follows f
        WHERE f.follower_id = ic.user_id AND f.followee_id = u.id
    ) AS following
FROM
    inserted_comment ic
        JOIN
    users u ON ic.user_id = u.id
`

type CreateCommentParams struct {
	Slug   string      `json:"slug"`
	UserID pgtype.Int8 `json:"userId"`
	Body   string      `json:"body"`
}

type CreateCommentRow struct {
	ID        int32            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"createdAt"`
	UpdatedAt pgtype.Timestamp `json:"updatedAt"`
	Body      string           `json:"body"`
	Username  string           `json:"username"`
	Bio       pgtype.Text      `json:"bio"`
	Image     pgtype.Text      `json:"image"`
	Following bool             `json:"following"`
}

// comment.sql
func (q *Queries) CreateComment(ctx context.Context, arg *CreateCommentParams) (CreateCommentRow, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Slug, arg.UserID, arg.Body)
	var i CreateCommentRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Body,
		&i.Username,
		&i.Bio,
		&i.Image,
		&i.Following,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments
WHERE id = $1 AND user_id = $2
`

type DeleteCommentParams struct {
	ID     int32       `json:"id"`
	UserID pgtype.Int8 `json:"userId"`
}

func (q *Queries) DeleteComment(ctx context.Context, arg *DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.UserID)
	return err
}

const getCommentsByArticleSlug = `-- name: GetCommentsByArticleSlug :many
SELECT
    c.id,
    TO_CHAR(c.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"') AS created_at,
    TO_CHAR(c.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"') AS updated_at,
    c.body,
    u.username,
    u.bio,
    u.image,
    FALSE AS following
FROM comments c
         JOIN users u ON c.user_id = u.id
WHERE c.article_id = (SELECT id FROM articles WHERE slug = $1)
`

type GetCommentsByArticleSlugRow struct {
	ID        int32       `json:"id"`
	CreatedAt string      `json:"createdAt"`
	UpdatedAt string      `json:"updatedAt"`
	Body      string      `json:"body"`
	Username  string      `json:"username"`
	Bio       pgtype.Text `json:"bio"`
	Image     pgtype.Text `json:"image"`
	Following bool        `json:"following"`
}

func (q *Queries) GetCommentsByArticleSlug(ctx context.Context, slug string) ([]GetCommentsByArticleSlugRow, error) {
	rows, err := q.db.Query(ctx, getCommentsByArticleSlug, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommentsByArticleSlugRow{}
	for rows.Next() {
		var i GetCommentsByArticleSlugRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Body,
			&i.Username,
			&i.Bio,
			&i.Image,
			&i.Following,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleComment = `-- name: GetSingleComment :one
SELECT
    c.id,
    c.created_at AS createdAt,
    c.updated_at AS updatedAt,
    c.body,
    u.username,
    u.bio,
    u.image,
    FALSE AS following  -- заменить на реальную логику определения, следует ли автору
FROM comments c
         JOIN users u ON c.user_id = u.id
WHERE c.id = (SELECT MAX(id) FROM comments)
`

type GetSingleCommentRow struct {
	ID        int32            `json:"id"`
	Createdat pgtype.Timestamp `json:"createdat"`
	Updatedat pgtype.Timestamp `json:"updatedat"`
	Body      string           `json:"body"`
	Username  string           `json:"username"`
	Bio       pgtype.Text      `json:"bio"`
	Image     pgtype.Text      `json:"image"`
	Following bool             `json:"following"`
}

func (q *Queries) GetSingleComment(ctx context.Context) (GetSingleCommentRow, error) {
	row := q.db.QueryRow(ctx, getSingleComment)
	var i GetSingleCommentRow
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.Body,
		&i.Username,
		&i.Bio,
		&i.Image,
		&i.Following,
	)
	return i, err
}
